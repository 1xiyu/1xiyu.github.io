<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="litchi"><link rel="alternative" href="/atom.xml" title="fe ? not exsit ?" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>运行时编译器组合与只包含运行时（vue） - fe ? not exsit ?</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">fe ? not exsit ?</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-06-19T12:32:04.354Z">June 19, 2018</time><h1 class="post__title"><a href="/2018/06/19/vue_runtime/">运行时编译器组合与只包含运行时（vue）</a></h1><div class="post__main echo"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="http://oixr9tno0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-19%20%E4%B8%8B%E5%8D%888.22.31.png" alt="lifecircle"></p>
<p>如vue的生命周期图所示，一个关键不可少的步骤： 编译的过程。用于连接vue初始的options与vdom机制的桥梁, 把options对象里面的数据和vue语法写的模版编译成redner函数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="http://oixr9tno0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-19%20%E4%B8%8B%E5%8D%887.53.11.png" alt="import"></p>
<p>明确版本vue2.5.17-beta.0，platforms/web/entry-runtime-with-compiler.js  &amp;&amp; platforms/web/entry-runtime.js。 从源码的这两个入口可以得出结论：</p>
<p>Vue提供了 2 个版本，一个是 Runtime + Compiler 的，一个是 Runtime only 的，前者是包含编译代码的，可以把编译过程放在运行时做，后者是不包含编译代码的，需要借助中间件事先把模板编译成 render函数。</p>
<p>在稍微看一下entry-runtime-with-compiler.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;</span><br><span class="line">    //存在options.render,直接render，也就是mount</span><br><span class="line">    if (!options.render) &#123;</span><br><span class="line">        var template = options.template;</span><br><span class="line">        // 有template，直接作为模版</span><br><span class="line">        if (template) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125; else if (el) &#123;</span><br><span class="line">        // 反之, el作为模版</span><br><span class="line">          template = getOuterHTML(el);</span><br><span class="line">        &#125;</span><br><span class="line">        if (template) &#123;</span><br><span class="line">          //如果获取了模版，转化为render</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  return mount.call(this, el, hydrating)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>程序优先检查render，找不到就查看是否有tempalte，再其次检查el属性从html文件里读区。<br>template是html模版，编译以后就成render函数了。代码运行的时候也会先把template编译成render，然后再用来渲染dom。</p>
<p>如若不使用vue-loader或vueify, 需要自己写个jsx的render函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 不需要编译器</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  //h函数即creatElement返回一个vdom（vnode树</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    return h(&apos;div&apos;, &apos;hello, world&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 需要编译器</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  template: &apos;&lt;div&gt;&#123;&#123;hi&#125;&#125;&lt;/div&gt;&apos;</span><br><span class="line">  data: () =&gt; (&#123;</span><br><span class="line">    hi: &apos;hello, world&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一般情况下，为了更加优雅便捷通常使用单文件组件模式，使用vue-loader编译成render的形式。总结一下，为了更好的性能，这两种方式最终结果都可以应用vue的runtime版本。webpack应用如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [&apos;.js&apos;, &apos;.vue&apos;],</span><br><span class="line">    alias: &#123;</span><br><span class="line">        //以esm加载方式为例</span><br><span class="line">        vue: &apos;vue/dist/vue.runtime.esm.js&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我的应用是简单应用，根本不希望引入webpack、vue-loader等中间件。那就用entry-runtime-with-compiler入口打包出来的完全体版本了，vue本身就存在一个解析模版引擎。当然性能也会变差，因为这个过程就要在浏览器的解析中运行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line">&lt;div&gt; hello, world&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//hello.js</span><br><span class="line">import template from &apos;./index.html&apos;;</span><br><span class="line">export default(&#123;</span><br><span class="line">  template</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// vue import.js</span><br><span class="line">import Hello from &apos;hello.js&apos;;</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;test&apos;,</span><br><span class="line">  template: &apos;&lt;hello&gt;&lt;/hello&gt;&apos;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Hello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//以上是一个在浏览器环境中解析的一个小版本。跑通例子需要webapck babel版本哦。。</span><br></pre></td></tr></table></figure>
<h2 id="利弊"><a href="#利弊" class="headerlink" title="利弊"></a>利弊</h2><ul>
<li>只包含运行时的好处其实也就是编译模版中间件的好处： <ul>
<li>如上所示预编译避免了运行时编译的开销。</li>
<li>避免了csp限制</li>
</ul>
</li>
<li>坏处<ul>
<li>依赖编译中间件。也就依赖webpack rollup等构建工具。</li>
<li>项目庞大时，由于需要vue-loader编译vue模版，导致编译过程过慢。</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[关于csp的知识]  <a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/09/csp.html</a></p>
</div></header></article><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC8zNjg0OS8xMzM4NQ=="><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2018 litchi</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>