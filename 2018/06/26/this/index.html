<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="litchi"><link rel="alternative" href="/atom.xml" title="fe ? not exsit ?" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>走进基础：this了解一下 - fe ? not exsit ?</title><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/js/jquery-3.1.1.min.js"></script><script src="/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/">fe ? not exsit ?</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/archives">カタログ/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"> <time class="post__time" datetime="2018-06-26T09:20:05.375Z">June 26, 2018</time><h1 class="post__title"><a href="/2018/06/26/this/">走进基础：this了解一下</a></h1><div class="post__main echo"><blockquote>
<p>this of javascript</p>
</blockquote>
<ul>
<li><p>三大特点</p>
<ul>
<li><p>this令人困惑。</p>
</li>
<li><p>this运行时绑定的产物</p>
</li>
<li><p>依赖函数调用的上下文环境。</p>
</li>
</ul>
</li>
</ul>
<p>javascript的作者当时戏说他也弄不清，就记住那四种方式（下文抛出）就ok。知识点1，一个函数调用会有一个执行环境。这个执行环境包含了是如何被调用的、传递的参数信息、this也是其中的一个属性。知识点2，多次提到的上下文，看一下它的生命周期。</p>
<p><img src="http://oixr9tno0.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-26%20%E4%B8%8A%E5%8D%8811.37.10.png" alt="周期图">;</p>
<p>大多数人的误区错把this和词法作用域混淆，上图也可以看出创建阶段计算出this和作用域链。那他们有关系吗？明确一下javascript中的this不会以任何方式指向词法作用域。作用域好像是一个将所有可用标识符作为属性的对象，这从内部来说是对的。但是JavasScript代码不能访问作用域“对象”。它是引擎的内部实现。</p>
<blockquote>
<p>meaning of exsit</p>
</blockquote>
<p>引入一个函数传参的例子，感受一下通过一个context传递调用的对象与this隐式传递的对比。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// use param context </span><br><span class="line"></span><br><span class="line">function animal(context) &#123;</span><br><span class="line">    return context.name;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bigDog(context) &#123;</span><br><span class="line">    console.log( `hello,$&#123;animal(context)&#125;`);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var name = &apos;anni&apos;;</span><br><span class="line"></span><br><span class="line">bigDog(window);  //hello anni</span><br><span class="line"></span><br><span class="line">// use this </span><br><span class="line"></span><br><span class="line">function animal() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bigDog() &#123;</span><br><span class="line">    console.log(`hello,$&#123;animal()&#125;`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var name = &apos;anni&apos;;</span><br><span class="line"></span><br><span class="line">bigDog();  //hello anni</span><br></pre></td></tr></table></figure>
<ul>
<li>更加优雅的传递引用</li>
<li>更加干净的API设计和更容易的复用</li>
</ul>
<blockquote>
<p>辨认规则：</p>
</blockquote>
<p>前人经过长期使用总结出一套使用规律。this与它所在方法的调用点有关，与方法所在声明没有关系，看下文这个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// obj声明位置</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;i am obj&apos;,</span><br><span class="line">    test: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// obj1声明位置</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &apos;i am obj1&apos;,</span><br><span class="line">    test1: obj.test</span><br><span class="line">&#125;</span><br><span class="line">// obj1调用位置</span><br><span class="line">obj1.test1();    // i am obj1</span><br></pre></td></tr></table></figure>
<p>wow, 厉害，我能辨认this了，不！还差得远呢。接着看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// egg.1</span><br><span class="line">function sayName() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;i am window&apos;;</span><br><span class="line">sayName();   // i am window</span><br><span class="line"></span><br><span class="line">//egg.2</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;i am obj&apos;,</span><br><span class="line">    say: sayName</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(obj.say, 1000);  // i am window</span><br></pre></td></tr></table></figure>
<p>what is the wrong? what is the fuck ?</p>
<p>然后又有一群人经过实验规律总结： this与它所在方法的调用点有关这条理论完全正确，不过这仅仅是规则，还需要配合方法论使用。确认where is this？前提是这条理论，还要配合以下四条方法论。</p>
<ol>
<li>默认绑定，函数独立调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// egg.1</span><br><span class="line">function sayName() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;i am window&apos;;</span><br><span class="line">sayName();   // i am window</span><br></pre></td></tr></table></figure>
<p>egg.1 就是默认绑定的具体应用。首先调用点是函数直接调用的。那么为什么默认绑定使用于这里？因为没有其他规则适用了。No way, 无法反驳，游戏的规则就是这样。</p>
<ol start="2">
<li>隐含绑定，如若隐含丢失则退回默认绑定, 调用点一般是一个拥有者或者容器。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// egg.2</span><br><span class="line">// obj声明位置</span><br><span class="line">var obj = &#123;</span><br><span class="line">    name: &apos;i am obj&apos;,</span><br><span class="line">    test: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// obj1声明位置</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    name: &apos;i am obj1&apos;,</span><br><span class="line">    test1: obj.test</span><br><span class="line">&#125;</span><br><span class="line">// obj1调用位置</span><br><span class="line">obj1.test1();    // i am obj1</span><br></pre></td></tr></table></figure>
<p>egg.2就是隐含绑定的具体应用。调用点是obj1，test的调用位置点指向obj1的引用，这个时候隐含绑定规则就会说这个对象的函数调用应该被this绑定。</p>
<h4 id="隐含丢失，即隐含绑定失效"><a href="#隐含丢失，即隐含绑定失效" class="headerlink" title="隐含丢失，即隐含绑定失效"></a>隐含丢失，即隐含绑定失效</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//egg.3</span><br><span class="line">var animal1 = &#123;</span><br><span class="line">    name: &apos;litchi&apos;,</span><br><span class="line">    say: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var animal2 = &#123;</span><br><span class="line">    name: &apos;hyc&apos;,</span><br><span class="line">    say: function() &#123;</span><br><span class="line">        var test = animal1.say;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">animal2.say();  // hello</span><br><span class="line"></span><br><span class="line">// egg.4 setTimeout setInterval 匿名函数执行的当前对象</span><br><span class="line">var animal1 = &#123;</span><br><span class="line">    name: &apos;litchi&apos;,</span><br><span class="line">    say: function() &#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;hyc&apos;;</span><br><span class="line">setTimeout( animal1.say, 1000);</span><br></pre></td></tr></table></figure>
<p>egg.3与egg.4 就是典型的隐含绑定中this丢失的实例。</p>
<ol start="3">
<li>明确绑定，call、apply</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// egg.5</span><br><span class="line">function foo() &#123;</span><br><span class="line">	console.log( this.name );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">	name: &apos;litchi&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.call( obj ); // litchi</span><br></pre></td></tr></table></figure>
<p>call应用，即明确绑定，apply和call没有除调用参数外无任何区别。但是它不能解决this绑定丢失、函数覆盖等等问题。</p>
<h4 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function sayName() &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var name = &apos;hyc&apos;;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;litchi&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function say() &#123;</span><br><span class="line">  return sayName.call(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say();</span><br><span class="line"></span><br><span class="line">say.call(obj);</span><br><span class="line"></span><br><span class="line">setTimeout(say, 1000);</span><br><span class="line"></span><br><span class="line">//litchi</span><br><span class="line">//litchi</span><br><span class="line">//litchi</span><br></pre></td></tr></table></figure>
<p>明确绑定的小变种， 通过一个函数包装的形式将this强制绑定到obj上。无论怎样都不会被覆盖。硬绑定 是一个如此常用的模式，它已作为 ES5 的内建工具提供：Function.prototype.bind。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function sayName() &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var name = &apos;hyc&apos;;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;litchi&apos;</span><br><span class="line">&#125;</span><br><span class="line">var a = sayName.bind(obj);</span><br><span class="line"></span><br><span class="line">a(); //litchi</span><br><span class="line">setTimeout(a, 1000); //litchi</span><br></pre></td></tr></table></figure>
<p>自己封装一个bind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function bindObj( fn, obj) &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return fn.call(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function sayName() &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var name = &apos;hyc&apos;;</span><br><span class="line"></span><br><span class="line">var obj = &#123;</span><br><span class="line">  name: &apos;litchi&apos;</span><br><span class="line">&#125;</span><br><span class="line">var a = bindObj(sayName, obj);</span><br><span class="line"></span><br><span class="line">a(); //litchi</span><br><span class="line">setTimeout(a, 1000); //litchi</span><br></pre></td></tr></table></figure>
<p> 接收我们回调的函数故意改变调用的 this。那些很流行的 JavaScript 库(jquery等)中的事件处理器就十分喜欢强制你的回调的 this 指向触发事件的 DOM 元素。</p>
<ol start="4">
<li>new绑定，使用新构建的对象</li>
</ol>
<p>首先，让我们重新定义 JavaScript 的“构造器”是什么。在 JS 中，构造器仅仅是一个函数，它们偶然地与前置的new操作符一起调用。它们不依附于类，它们也不初始化一个类。它们甚至不是一种特殊的函数类型。它们本质上只是一般的函数，在被使用 new 来调用时改变了行为。new的默认行为如下：</p>
<pre><code>1. 新对象被构建分配内存
2. 将新创建的对象接入原型链
3. 将新创建的对象设置函数调用的this绑定
4. 除非函数返回一个它自己的其他对象，否则这个被new调用的函数将自动返回这个新构建的对象。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(name) &#123;</span><br><span class="line">    this.name = name || &apos;&apos;;</span><br><span class="line">&#125;</span><br><span class="line">var bar = new foo(&apos;litchi&apos;);</span><br><span class="line">console.log(bar.name);  //litchi</span><br></pre></td></tr></table></figure>
<p>构建了一个新对象bar， 把bar作为函数调用的this。</p>
<blockquote>
<p>es6中的箭头函数</p>
</blockquote>
<p>this是根据函数声明的时候确定的，也就是跟随词法作用域。</p>
<blockquote>
<p>node中的this</p>
</blockquote>
<p>node cli 与浏览器环境保持一致，脚本环境不一致，不做讨论。</p>
</div></header></article><div class="comments" id="lv-container" data-id="city" data-uid="MTAyMC8zNjg0OS8xMzM4NQ=="><script>(function(d, s) {var j, e = d.getElementsByTagName(s)[0];if (typeof LivereTower === 'function') { return; } j = d.createElement(s);j.src = 'https://cdn-city.livere.com/js/embed.dist.js';j.async = true;e.parentNode.insertBefore(j, e);})(document, 'script');</script></div></main><footer class="foot"><div class="foot-copy">&copy; 2016-2018 litchi</div></footer><script src="/js/scroller.js"></script><script src="/js/main.js"></script></body></html>